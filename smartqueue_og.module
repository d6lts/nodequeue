<?php
/**
 * Implementation of hook_nodequeue_info()
 */
function smartqueue_og_nodequeue_info() {
  return array('smartqueue_og' =>
    array(
      'title' => t('Smartqueues for Organic Groups'),
      'description' => t('Provides a Node Queue for each Organic Group'),
    )
  );
}

function smartqueue_og_nodequeue_form($queue, &$form) {
  $og_types = og_get_types('group');
  //@TODO: Get the human-readable names for these.
  $form['eligible_group_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t("Group types which are eligible for a Node Queue"),
    '#description' => t("Select the Organic Group types for which node queues be automatically created."),
    '#options' => $og_types,
    '#default_value' => variable_get('smartqueue_og_'. smartqueue_og_get_qid() .'_eligible_group_types', array()),
    '#weight' => 1,
  );
  $form['submit_actions'] = array(
    '#type' => 'fieldset',
    '#title' => t('Batch operations to perform when this form is submitted:'),
    '#weight' => 8,
    '#tree' => TRUE,
  );
  $form['submit_actions']['destroy'] = array(
    '#type' => 'radios',
    '#title' => 'For User-NodeQueues for roles that should no longer have nodequeues',
    '#options' => array(
      //'disable' => t('Disable these NodeQueues'), This isn't possible on a per-SubQueue basis with the current Node Queue API.
      'delete' => t('Delete these NodeQueues'),
      'nothing' => t('Take no action on these NodeQueues'),
    ),
  );
  $form['submit_actions']['create'] = array(
    '#prefix' => "<label>". t("For Users of the above-specified roles who do not yet have user NodeQueues:") ."</label>",
    '#type' => 'checkbox',
    '#title' => t('Create new NodeQueues'),
    '#default_value' => 1,
  );
  //drupal_set_message(dprint_r($form['eligible_group_types']['#default_value'], TRUE));
  drupal_set_message("mine". dprint_r($form['eligible_group_types']['#options'], TRUE));
}

function smartqueue_og_nodequeue_form_submit(&$queue, $form_values) {
  variable_set('smartqueue_og_'. $queue->qid . '_eligible_group_types', $form_values['eligible_group_types']);
if ($form_values['values']['submit_actions']['create'] == 1) {
  //get eligible gorups
  //get existing subqueues
  //get groups without subquques
  //batch add
/*  
    $groups = smartqueue_og_get_eligible_groups();
    $existing_subqueues = smartqueue_users_get_all_user_subqueues();
    $accounts_without_subqueues = array_diff_key($accounts, $existing_subqueues);
    smartqueue_users_batch_add_subqueues($accounts_without_subqueues);
*/
}

  switch ($form_values['values']['submit_actions']['destroy']) {
    case 'delete':
      drupal_goto('admin/content/nodequeue/smartqueue_og/batch_delete');
      break;
    //case 'disable':
      //smartqueue_users_batch_disable_subqueues(array_values($extra_subqueues);
  }
}


function smartqueue_og_all_eligible_group_nids() {
  $eligible_types = smartqueue_og_eligible_group_types();
  drupal_set_message("eligible types ". dprint_r($eligible_types, TRUE));
  $in = 'IN ('. implode(', ', array_fill(0, count($eligible_types), "'%s'")). ')';
  $a = array($types, $in);
  list($eligible_types, $in ) = $a;
  $query = db_query("SELECT nid, title FROM {node} WHERE type $in", $eligible_types);
  drupal_set_message("in = $in");
  while ($result = db_fetch_object($query)) {
    $groups[$result->nid] = $result->title;
    drupal_set_message("got a result");
  }
  return $groups;
}

function smartqueue_og_all_group_subqueues() {
  $subqueues = array();
  //returns an array keyed on the subqueue reference with the sq id as the value
  $qid = smartqueue_og_get_qid();
  $query = db_query("SELECT sqid, reference FROM {nodequeue_subqueue} WHERE qid = %d", $qid);
  while ($result = db_fetch_array($query)) {
    $subqueues[$result['reference']] = $result['sqid'];
  }
  return $subqueues;
}

function smartqueue_og_eligible_group_types() {
  return variable_get('smartqueue_og_'. smartqueue_og_get_qid() .'_eligible_group_types', array());
}

function smartqueue_og_eligible_group_type($type) {
  if (in_array(variable_get('smartqueue_og_'. smartqueue_og_get_qid() .'_eligible_group_types', array()), $type)) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

function smartqueue_og_nodequeue_subqueues(&$queue, $node) {
  global $user;
  $qid = smartqueue_og_get_qid();
  //Get all subqueues asssociated with the current user's groups:

  if (!is_array($user->og_groups)) {
    return;
  }
  $group_nids = array_keys($user->og_groups);
  drupal_set_message("group nids". dprint_r($group_nids, TRUE));
  $subqueues = nodequeue_load_subqueues_by_reference(array($qid => $group_nids));
  //Does the current user have access to manipulate queues?
  //is the current user a member of a (matching?) group?

  //is this a group node?
  //are there any subqueues associated with it?
  //Are members allowed to edit the nodequeue or are group admins?
  //
  //Later: Does this nodequeue (or og?) specify whether posts in this nodequeue are restricted to those within the group or not?
  
}

function smartqueue_og_queue_access($queue, $account = NULL) {
  
}

function smarqueue_og_subqueue_access($subqueue, $account = NULL) {
  
}

function smartqueue_og_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'insert':
    case 'update':
      if (smartqueue_og_eligible_group_type($node->type)) {
        if ($subqueue = !smartqueue_og_load_group_subqueue($node->nid)) {
          nodequeue_add_subqueue(smartqueue_og_get_qid(), "$node->title's Node Queue", $node->nid);
          drupal_set_message(t("Created a Node Queue for @title .", array('@title' => $node->title)));
        }
        else {
          //if ($subqueue->title != "$node->title's Subqueue  "
        }
      }
      break;
    case 'delete':
  }
//1) When an eligible OG homepage node is created, a nodequeue that corresponds to that OG homepage node will be created.
//2) When an eligible OG homepage node is deleted, the corresponding nodequeue will be deleted
}


function smartqueue_og_get_qid() {
  static $qid;
  if (!isset($qid)) {
    $qid = db_result(db_query("SELECT qid FROM {nodequeue_queue} WHERE owner = 'smartqueue_og'"));
  }
  return $qid;
}

function smartqueue_og_load_group_subqueue($nid) {
  return nodequeue_load_subqueues_by_reference(array(smartqueue_og_get_qid() => array($nid)));
}
