<?php
// $Id$

// --------------------------------------------------------------------------
// Drupal Hooks

/**
 * Implementation of hook_perm
 */
function nodequeue_perm() {
  return array ('manipulate queues', 'administer nodequeue', 'manipulate all queues');
}

/**
 * Implementation of hook_init().
 *
 * Loads subsidiary includes for other modules.
 */
function nodequeue_init() {
  if (module_exists('actions')) {
    include_once drupal_get_path('module', 'nodequeue') . '/nodequeue.actions.inc';
  }

  if (module_exists('views')) {
    include_once drupal_get_path('module', 'nodequeue') . '/nodequeue.views.inc';
  }
}

/**
 * Implementation of hook_menu
 */
function nodequeue_menu($may_cache) {
  $items = array();
  global $user;

  $admin_access = user_access('administer nodequeue');

  if ($may_cache) {
    // administrative items
    $access = user_access('administer nodequeue');
    $items[] = array(
      'path' => 'admin/content/nodequeue',
      'title' => t('Node queue'),
      'access' => $admin_access,
      'callback' => 'nodequeue_view_queues',
      'description' => t('Create and maintain simple node queues.'),
      'type' => MENU_NORMAL_ITEM
    );
    $items[] = array(
      'path' => 'admin/content/nodequeue/list',
      'title' => t('List'),
      'access' => $admin_access,
      'callback' => 'nodequeue_view_queues',
      'weight' => -1,
      'type' => MENU_DEFAULT_LOCAL_TASK
    );
    $info = nodequeue_api_info();
    foreach ($info as $key => $data) {
      $items[] = array(
        'path' => 'admin/content/nodequeue/add/' . $key,
        'title' => t('Add @type', array('@type' => strtolower($data['title']))),
        'access' => $admin_access,
        'callback' => 'drupal_get_form',
        'callback arguments' => array('nodequeue_edit_queue_form', $key),
        'type' => MENU_LOCAL_TASK
      );
    }
  }
  else {
    if ($user && arg(0) == 'node' && is_numeric(arg(1)) && arg(1) > 0 && ($access = user_access('manipulate queues'))) {
      $node = node_load(arg(1));
      // nodequeue tab for a node.
      if ($node && $queues = nodequeue_load_queues_by_type($node->type, 'tab')) {
        $items[] = array(
          'path' => 'node/' . arg(1) . '/nodequeue',
          'title' => variable_get('nodequeue_tab_name', t('Node queue')),
          'access' => $access,
          'callback' => 'nodequeue_node_tab',
          'callback arguments' => array($node, $queues),
          'type' => MENU_LOCAL_TASK,
          'weight' => 5
        );
      }
    }

    // Administrative items for an individual queue.
    if (user_access('manipulate queues') &&
        arg(0) == 'admin' &&
        arg(1) == 'content' &&
        arg(2) == 'nodequeue' &&
        is_numeric(arg(3)) &&
        $queue = nodequeue_load(arg(3))) {

      $access = nodequeue_queue_access($queue);
      drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
      $items[] = array(
        'path' => 'admin/content/nodequeue/' . $queue->qid,
        'access' => $access,
        'callback' => 'nodequeue_admin_view',
        'callback arguments' => array($queue),
        'type' => MENU_CALLBACK
      );
      $items[] = array(
        'path' => 'admin/content/nodequeue/' . $queue->qid . '/view',
        'title' => t('View'),
        'access' => $access,
        'callback' => 'nodequeue_admin_view',
        'callback arguments' => array($queue),
        'weight' => -10,
        'type' => MENU_DEFAULT_LOCAL_TASK
      );
      // Actual administrative items.
      $items[] = array(
        'path' => 'admin/content/nodequeue/' . $queue->qid . '/edit',
        'title' => t('Edit'),
        'access' => $admin_access,
        'callback' => 'drupal_get_form',
        'callback arguments' => array('nodequeue_edit_queue_form', $queue),
        'type' => MENU_LOCAL_TASK
      );
      $items[] = array(
        'path' => 'admin/content/nodequeue/' . $queue->qid . '/delete',
        'title' => t('Delete'),
        'access' => $admin_access,
        'callback' => 'drupal_get_form',
        'callback arguments' => array('nodequeue_admin_delete', $queue),
        'weight' => 5,
        'type' => MENU_CALLBACK
      );

      $sqid = arg(5);
      if (is_numeric($sqid) && $subqueue = nodequeue_load_subqueue($sqid)) {
        // The following operations require a sqid and a nid.
        $nid = arg(6);
        if (in_array(arg(4), array('add', 'remove-node')) &&
            is_numeric($nid)) {
          $node = node_load($nid);
        }

        if ($node && nodequeue_node_access($node->type)) {
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/add/$sqid/$nid",
            'access' => $access,
            'callback' => 'nodequeue_admin_add_node',
            'callback arguments' => array($queue, $subqueue, $node),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/remove-node/$sqid/$nid",
            'access' => $access,
            'callback' => 'nodequeue_admin_remove_node',
            'callback arguments' => array($queue, $subqueue, $node),
            'type' => MENU_CALLBACK
          );
        }

        if (is_numeric($nid)) {
          // IN this case, $nid is actually $pos but why rename the var?
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/up/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_up',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/down/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_down',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/front/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_front',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/back/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_back',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/remove/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_remove',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
        }
        $items[] = array(
          'path' => "admin/content/nodequeue/$queue->qid/clear/$sqid",
          'title' => t('Clear'),
          'access' => $access,
          'callback' => 'drupal_get_form',
          'callback arguments' => array('nodequeue_clear_confirm', $queue, $subqueue),
          'type' => MENU_CALLBACK
        );
      }
    }
  }
  return $items;
}
/**
 * Implementation of hook_nodeapi
 */
function nodequeue_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch($op) {
    case 'delete':
      // If a node is being deleted, ensure it's also removed from any queues.
      $result = db_query("SELECT * FROM {nodequeue_nodes} WHERE nid = %d", $node->nid);
      while ($obj = db_fetch_object($result)) {
        // This removes by nid, not position, because if we happen to have a
        // node in a queue twice, the 2nd position would be wrong.
        nodequeue_subqueue_remove_node($obj->sqid, $node->nid);
      }
      break;
  }
}

/**
 * Implementation of hook_link
 */
function nodequeue_link($type, $node = NULL, $teaser = FALSE) {
  if ($type == 'node' && variable_get('nodequeue_links', FALSE) && user_access('manipulate queues')) {
    $queues = nodequeue_load_queues_by_type($node->type, 'links');
    $subqueues = nodequeue_get_subqueues_by_node($queues, $node);
    if (empty($subqueues)) {
      return;
    }

    // resort the subqueues to retain consistent ordering:

    ksort($subqueues);
    nodequeue_set_subqueue_positions($subqueues, $node->nid);

    foreach ($subqueues as $subqueue) {
      $queue = $queues[$subqueue->qid];
      if (!isset($subqueue->position)) {
        $links['nodequeue-ajax-toggle-' . $subqueue->sqid] = array(
          'title' => nodequeue_title_substitute($queue->link, $queue, $subqueue),
          'href' => "admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid",
          'attributes' => array('class' => 'nodequeue-ajax-toggle'),
          'query' => drupal_get_destination());
      }
      else if ($queue->link_remove) {
        $links['nodequeue-ajax-toggle-' . $subqueue->sqid] = array(
          'title' => nodequeue_title_substitute($queue->link_remove, $queue, $subqueue),
          'href' => "admin/content/nodequeue/$queue->qid/remove/$subqueue->sqid/$node->nid",
          'attributes' => array('class' => 'nodequeue-ajax-toggle'),
          'query' => drupal_get_destination());
      }
    }
    drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
  }
  return $links;
}

// --------------------------------------------------------------------------
// Nodequeue Admin operations

/**
 * Print the JSON output for our AJAX calls.
 */
function nodequeue_js_output($label, $href, $count = NULL, $sqid = NULL) {
  $return = new stdClass();
  $return->status = 1;
  $return->label = check_plain($label);
  $return->href = $href;
  if (isset($count)) {
    $return->count = $count;
  }
  if (isset($sqid)) {
    $return->sqid = $sqid;
  }

  // let the world know this isn't normal output.
  drupal_set_header('text/javascript');
  print drupal_to_js($return);
  exit;
}

/**
 * Page callback to add a node to a queue.
 */
function nodequeue_admin_add_node($queue, $subqueue, $node) {
  nodequeue_subqueue_add($queue, $subqueue, $node->nid);

  // Provide a response if this is javascript.
  if (!empty($_POST['js'])) {
    if (isset($_GET['tab'])) {
      nodequeue_js_output(t('Remove from queue'),
        url("admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid", "tab"),
        nodequeue_subqueue_size_text($queue->size, min($subqueue->count + 1, $queue->size), FALSE),
        $subqueue->sqid);
    }
    else {
      nodequeue_js_output(nodequeue_title_substitute($queue->link_remove, $queue, $subqueue),
        url("admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid"));
    }
  }
  // There should always be a destination set for this, so just goto wherever.
  drupal_goto();
}

/**
 * Page callback to remove a node from a queue.
 */
function nodequeue_admin_remove_node($queue, $subqueue, $node) {
  nodequeue_subqueue_remove_node($subqueue->sqid, $node->nid);

  // Provide a response if this is javascript.
  if (!empty($_POST['js'])) {
    if (isset($_GET['tab'])) {
      nodequeue_js_output(t('Add to queue'),
        url("admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid", "tab"),
        nodequeue_subqueue_size_text($queue->size, $subqueue->count - 1, FALSE),
        $subqueue->sqid);
    }
    else {
      nodequeue_js_output(nodequeue_title_substitute($queue->link, $queue, $subqueue),
        url("admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid"));
    }
  }
  // There should always be a destination set for this, so just goto wherever.
  drupal_goto();
}

/**
 * Display the queue controls for a node.
 *
 * @param $node
 *   The loaded $node; will be loaded by the hook_menu.
 * @param $queues
 *   The list of queues. Loaded by the menu in order to test access control.
 */
function nodequeue_node_tab($node, $queues) {
  $header = array(
    array('data' => t('Title'), 'class' => 'nodequeue-title'),
    array('data' => t('Max nodes'), 'class' => 'nodequeue-max-nodes'),
    array('data' => t('In queue'), 'class' => 'nodequeue-in-queue'),
    array('data' => t('Operation'), 'class' => 'nodequeue-operation'),
  );
  $subqueues = nodequeue_get_subqueues_by_node($queues, $node);

  nodequeue_set_subqueue_positions($subqueues, $node->nid);

  $rows = array();
  foreach ($subqueues as $subqueue) {
    $queue = $queues[$subqueue->qid];
    if (!$subqueue->position) {
      $op = l(
        t('Add to queue'),
        "admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid",
        array('class' => 'nodequeue-ajax-toggle'),
        drupal_get_destination() . '&tab'
      );
    }
    else {
      $op = l(
        t('Remove from queue'),
        "admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid",
        array('class' => 'nodequeue-ajax-toggle'),
        drupal_get_destination() . '&tab'
      );
    }
    $rows[] = array(
      array(
        'class' => 'nodequeue-title',
        'data' => check_plain(nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue)),
      ),
      array('class' => 'nodequeue-max-nodes', 'data' => $queue->size ? $queue->size : t('Infinite')),
      array(
        'id' => 'nodequeue-count-' . $subqueue->sqid,
        'class' => 'nodequeue-in-queue',
        'data' => nodequeue_subqueue_size_text($queue->size, $subqueue->count, FALSE)
      ),
      array('class' => 'nodequeue-operation', 'data' => $op),
    );
  }

  $output .= theme('table', $header, $rows, array('class' => 'nodequeue-table'));
  drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
  drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');

  return $output;
}

/**
 * Display a list of queues and their status for the administrator.
 */
function nodequeue_view_queues() {
  // Fetch all of the queues.
  $queues = nodequeue_load_queues(nodequeue_get_all_qids(25));
  if (empty($queues)) {
    return t('No node queues exist.');
  }

  $qids = array();
  // For every queue that has exactly 1 subqueue,
  foreach ($queues as $queue) {
    if ($queue->subqueues == 1) {
      $qids[] = $queue->qid;
    }
  }

  $subqueues = nodequeue_load_subqueues_by_queue($qids);
  // Relate all the subqueues we loaded back to our queues.
  foreach ($subqueues as $subqueue) {
    $queues[$subqueue->qid]->subqueue = $subqueue;
  }

  $header = array(t('Title'), t('Max nodes'), t('Subqueues'), t('Operation'));

  $rows = array();
  foreach ($queues as $queue) {
    $sub_text = $queue->subqueues;
    if ($sub_text == 1) {
      $sub_text .= " (" . nodequeue_subqueue_size_text($queue->size, $queue->subqueue->count) . ")";
    }

    $rows[] = array(
      array('class' => 'nodequeue-title', 'data' => check_plain($queue->title)),
      array('class' => 'nodequeue-max-nodes', 'data' => $queue->size == 0 ? t('Infinite') : $queue->size),
      array('class' => 'nodequeue-subqueues', 'data' => $sub_text),
      array('class' => 'nodequeue-operation', 'data' => implode(' | ', array(l(t('Edit'), "admin/content/nodequeue/$queue->qid/edit"), l(t('View'), "admin/content/nodequeue/$queue->qid/view"), l(t('Delete'), "admin/content/nodequeue/$queue->qid/delete"))))
      );
  }

  $output = theme('table', $header, $rows);
  $output .= theme('pager', NULL, 25);

  return  $output;
}

/**
 * Display a list of subqueues for a queue and their sizes
 */
function nodequeue_view_subqueues($queue) {
  // Fetch all of the subqueues.
  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);

  $header = array(t('Title'), t('In queue'), t('Operation'));

  $rows = array();
  foreach ($subqueues as $subqueue) {
    $sub_text = nodequeue_subqueue_size_text($queue->size, $subqueue->count, FALSE);
    $rows[] = array(
      array('class' => 'nodequeue-title', 'data' => check_plain($subqueue->title)),
      array('class' => 'nodequeue-subqueues', 'data' => $sub_text),
      array('class' => 'nodequeue-operation', 'data' => l(t('View'), "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid"))
    );
  }

  $output = '<p>' . t('Max nodes in queue: @size', array('@size' => $queue->size ? $queue->size : t("Infinite"))) . '</p>';
  $output .= theme('table', $header, $rows);
  $output .= theme('pager', NULL, 20);

  return  $output;
}

/**
 * Add or edit a queue.
 */
function nodequeue_edit_queue_form($queue) {
  // For adding queues.
  if (is_string($queue)) {
    $queue = new nodequeue_queue($queue);
  }

  $info = nodequeue_api_info();

  $form['description'] = array(
    '#type' => 'fieldset',
    '#title' => $info[$queue->owner]['title'],
    '#description' => $info[$queue->owner]['description'],
  );

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#default_value' => $queue->title,
    '#size' => 50,
    '#maxlength' => 64,
    '#description' => t('Enter the name of the queue'),
  );

  // This is a value; as the default nodequeue implementation has just one
  // queue per nodequeue, this field is totally redundant. Plugins can
  // override this.
  $form['subqueue_title'] = array(
    '#type' => 'value',
    '#value' => $queue->subqueue_title,
  );
  // The placeholder is put here so that modifiers have an easy way to put
  // additional form widgets in a prominent spot but not before the title of
  // the queue.
  $form['placeholder'] = array();

  $form['size'] = array(
    '#type' => 'textfield',
    '#title' => t('Queue size'),
    '#default_value' => $queue->size,
    '#size' => 2,
    '#maxlength' => 2,
    '#description' => t('The maximum number of nodes will appear in the queue. Enter 0 for no limit'),
  );

  $form['link'] = array(
    '#type' => 'textfield',
    '#title' => t('Link "add to queue" text'),
    '#default_value' => $queue->link,
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => t('If you want a link to add a node to a queue in the "links" section (next to "add new comment"), enter the text here. If left blank no link will be given; note that enabling this feature for any queue will cause an extra query to be run every time a node is loaded. "%subqueue" will be replaced with the subqueue title, if applicable.'),
  );

  $form['link_remove'] = array(
    '#type' => 'textfield',
    '#title' => t('Link "remove from queue" text'),
    '#default_value' => $queue->link_remove,
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => t('Enter the text for the corresponding link to remove a node from a queue. This may be blank (in which case no link will appear) but a remove link will only appear if link, above, is set.'),
  );

  $result = db_query("SELECT * FROM {role} ORDER BY name");
  while ($role = db_fetch_object($result)) {
    $roles[$role->rid] = $role->name;
  }

  $form['roles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Roles'),
    '#default_value' => $queue->roles,
    '#options' => $roles,
    '#description' => t('Check each role that can add nodes to the queue.'),
  );

  foreach (node_get_types() as $type => $info) {
    $nodes[$type] = $info->name;
  }

  $form['types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Types'),
    '#default_value' => $queue->types,
    '#options' => $nodes,
    '#description' => t('Check each node type that can be added to this queue.'),
  );

  $form[] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  $form['owner'] = array(
    '#type' => 'value',
    '#value' => $queue->owner,
  );

  $form['show_in_links'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_links,
  );

  $form['show_in_tab'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_tab,
  );

  $form['show_in_ui'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_ui,
  );

  $form['reference'] = array(
    '#type' => 'value',
    '#value' => $queue->reference,
  );

  $form['subqueues'] = array(
    '#type' => 'value',
    '#value' => $queue->subqueues,
  );

  if (isset($queue->qid)) {
    $form[] = array(
      '#type' => 'submit',
      '#value' => t('Delete'),
    );
    $form['qid'] = array(
      '#type' => 'value',
      '#value' => $queue->qid,
    );
    $form['count'] = array(
      '#type' => 'value',
      '#value' => $queue->count,
    );
  }

  nodequeue_api_queue_form($queue, $form);

  return $form;
}

/**
 * Submit function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_validate($formid, $form_values, &$form) {
  if ($form_values['op'] == t('Delete')) {
    return;
  }
  $queue = (object) $form_values;
  // fix checkboxes
  $queue->roles = array_keys(array_filter($queue->roles));
  $queue->types = array_keys(array_filter($queue->types));

  if (!isset($queue->qid)) {
    $queue->new = TRUE;
  }

  nodequeue_api_queue_form_validate($queue, $form_values, $form);
}

/**
 * Submit function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_submit($formid, $form) {
  if ($form['op'] == t('Delete')) {
    return "admin/content/nodequeue/$form[qid]/delete";
  }

  $queue = (object) $form;
  // fix checkboxes
  $queue->roles = array_keys(array_filter($queue->roles));
  $queue->types = array_keys(array_filter($queue->types));

  if (!isset($queue->qid)) {
    $queue->new = TRUE;
  }

  // Modify show_in_links based on whether or not links are available.
  $queue->show_in_links = !empty($queue->link) && !empty($queue->link_remove);

  nodequeue_api_queue_form_submit($queue, $form);

  $qid = nodequeue_save($queue);

  nodequeue_api_queue_form_submit_finish($queue, $form);

  nodequeue_check_subqueue_sizes($queue);

  if ($queue->new) {
    drupal_set_message(t('The queue has been created.'));
  }
  else {
    drupal_set_message(t('The queue has been updated.'));
  }
  return 'admin/content/nodequeue';
}

/**
 * Confirm form to delete a queue
 */
function nodequeue_admin_delete($queue) {
  $form['qid'] = array('#type' => 'value', '#value' => $queue->qid);
  return confirm_form($form,
    t('Are you sure you want to delete "%title"?', array('%title' => $queue->title)),
    $_GET['destination'] ? $_GET['destination'] : 'admin/content/nodequeue',
    t('This action cannot be undone.'),
    t('Delete'), t('Cancel')
  );
}

/**
 * Submit function for nodequeue delete
 */
function nodequeue_admin_delete_submit($formid, $form) {
  if ($form['confirm']) {
    nodequeue_delete($form['qid']);
    drupal_set_message("The queue has been deleted.");
  }
  return 'admin/content/nodequeue';
}

/**
 * Page callback to view a queue.
 */
function nodequeue_admin_view($queue, $sqid = NULL) {
  $qid = $queue->qid;

  // If the queue has just one subqueue, it gets special treatment.
  if (!$sqid) {
    if ($queue->subqueues == 1) {
      $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
      $subqueue = array_shift($subqueues);
    }
    else {
      // display subqueue list page.
      return nodequeue_view_subqueues($queue);
    }
    $sqid = $queue->current;
  }
  else if ($sqid) {
    // Adjust properties of the page so our subqueue is in the right
    // visual place.
    $subqueue = nodequeue_load_subqueue($sqid);
    drupal_set_title(t("Subqueue '@title'", 
      array('@title' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))));
    $breadcrumb = drupal_get_breadcrumb();
    $breadcrumb[] = l($queue->title, "admin/content/nodequeue/$queue->qid");
    drupal_set_breadcrumb($breadcrumb);
  }

  return nodequeue_admin_view_subqueue($queue, $subqueue);
}

/**
 * View the contents of a subqueue, with links to re-order the queue.
 */
function nodequeue_admin_view_subqueue($queue, $subqueue) {
  $qid = $queue->qid;
  $sqid = $subqueue->sqid;
  $output = '';

  $output = '<p class="nodequeue-js-hide">';
  $output .= t('Changes made to the queue order and queue removals will not be active until you click Save, below.');
  $output .= '</p>';
  $result = db_query("SELECT DISTINCT(n.nid), n.title, n.uid, u.name, n.created, nq.position FROM {node} n LEFT JOIN {users} u on n.uid = u.uid LEFT JOIN {nodequeue_nodes} nq ON nq.nid = n.nid WHERE nq.sqid = %d ORDER BY nq.position", $sqid);

  $list = array();

  while ($node = db_fetch_object($result)) {
    $buttons = l(
      theme('image', drupal_get_path('module', 'nodequeue') .'/go-up.png', t('Move up')),
      "admin/content/nodequeue/$qid/up/$sqid/$node->position",
      array(
        'title' => t('Move up'),
        'class' => 'nodequeue-move-up',
      ), drupal_get_destination(), NULL, FALSE, TRUE);
    $buttons .= l(
      theme('image', drupal_get_path('module', 'nodequeue') .'/go-down.png', t('Move down')),
      "admin/content/nodequeue/$qid/down/$sqid/$node->position",
      array(
        'title' => t('Move down'),
        'class' => 'nodequeue-move-down',
      ), drupal_get_destination(), NULL, FALSE, TRUE);
    $buttons .= l(
      theme('image', drupal_get_path('module', 'nodequeue') .'/go-top.png', t('Move to front')),
      "admin/content/nodequeue/$qid/front/$sqid/$node->position",
      array(
        'title' => t('Move to front'),
        'class' => 'nodequeue-move-front',
      ), drupal_get_destination(), NULL, FALSE, TRUE);
    $buttons .= l(
      theme('image', drupal_get_path('module', 'nodequeue') .'/go-bottom.png', t('Move to back')),
      "admin/content/nodequeue/$qid/back/$sqid/$node->position",
      array(
        'title' => t('Move to back'),
        'class' => 'nodequeue-move-back',
      ), drupal_get_destination(), NULL, FALSE, TRUE);
    $buttons .= l(
      theme('image', drupal_get_path('module', 'nodequeue') .'/user-trash.png', t('Remove from queue')),
      "admin/content/nodequeue/$qid/remove/$sqid/$node->position",
      array(
        'title' => t('Remove from queue'),
        'class' => 'nodequeue-remove',
      ), drupal_get_destination(), NULL, FALSE, TRUE);
    $list[] = array(
      'id' => 'nodequeue-row-' . $node->position,
      'class' => 'nodequeue-row',
      'data' => array(l($node->title, "node/$node->nid"), theme('username', $node), format_date($node->created), $buttons),
    );
    $nids[$node->position] = $node->nid;
  }

  if (!empty($list)) {
    $header = array(t('Node'), t('Author'), t('Date'), t('Operation'));
    $output .= theme('table', $header, $list, array('width' => '100%', 'id' => 'nodequeue-table'));

    $output .= drupal_get_form('nodequeue_admin_view_subqueue_form', $qid, $sqid, $nids);
    drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
  }
  else {
    $output .= t('<p>Queue is empty!</p>');
  }

  return $output;
}

/**
 * Page callback to move an item up in a queue. This will be used only if
 * javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_up($queue, $subqueue, $pos) {
  // This function is safe if $pos is out of bounds.
  nodequeue_queue_up($subqueue, $pos);
  drupal_goto();
}

/**
 * Page callback to move an item down in a queue. This will be used only if
 * javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_down($queue, $subqueue, $pos) {
  // This function is safe if $pos is out of bounds.
  nodequeue_queue_down($subqueue, $pos);
  drupal_goto();
}

/**
 * Page callback to move an item to the front of a queue. This will be used
 * only if javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_front($queue, $subqueue, $pos) {
  // This function is safe if $pos is out of bounds.
  nodequeue_queue_front($subqueue, $pos);
  drupal_goto();
}

/**
 * Page callback to move an item to the back of a queue. This will be used
 * only if javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_back($queue, $subqueue, $pos) {
  // This function is safe if $pos is out of bounds.
  nodequeue_queue_back($subqueue, $pos);
  drupal_goto();
}

/**
 * Page callback to remove an item from a queue. This will be used only
 * if javascript is disabled in the client, and is a fallback technique.
 * This differs from nodequeue_admin_remove_node in that it removes a
 * specific position, which is necessary in case a node is in a queue
 * multiple times.
 */
function nodequeue_admin_remove($queue, $subqueue, $pos) {
  nodequeue_subqueue_remove($subqueue->sqid, $pos);
  drupal_goto();
}

/**
 * Form used for administrating a queue
 */
function nodequeue_admin_view_subqueue_form($qid, $sqid, $nids) {
  $form['qid'] = array(
    '#type' => 'value',
    '#value' => $qid,
  );

  $form['sqid'] = array(
    '#type' => 'value',
    '#value' => $sqid,
  );

  $form['order'] = array(
    '#type' => 'hidden',
    '#id' => 'nodequeue-order',
    '#default_value' => implode(',', array_keys($nids)),
  );

  $form['save'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-js-hide nodequeue-save', 'style' => 'display: none'),
    '#value' => t('Save'),
  );

  $form['clear'] = array(
    '#type' => 'submit',
    '#value' => t('Clear queue'),
  );

  // Store the original order.
  $form['nids'] = array(
    '#type' => 'value',
    '#value' => $nids,
  );
  return $form;
}

/**
 * Submit function for nodequeue_admin_view_subqueue_form
 */
function nodequeue_admin_view_subqueue_form_submit($form_id, $form_values) {
  if ($form_values['op'] == t('Clear queue')) {
    return 'admin/content/nodequeue/' . $form_values['qid'] . '/clear/' . $form_values['sqid'];
  }

  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d", $form_values['sqid']);
  if ($form_values['order']) {
    $now = time();
    $sql = '';
    $args = array();
    $nids = $form_values['nids'];

    foreach (explode(',', $form_values['order']) as $new_pos => $old_pos) {
      if ($sql) {
        $sql .= ', ';
      }
      $sql .= ' (%d, %d, %d, %d, %d)';
      $args[] = $form_values['sqid'];
      $args[] = $form_values['qid'];
      $args[] = $nids[$old_pos];

      // $new_pos starts from 0 but we start from 1.
      $args[] = $new_pos + 1;
      $args[] = $now;
    }
    $sql = "INSERT INTO {nodequeue_nodes} (sqid, qid, nid, position, timestamp) VALUES $sql";
    db_query($sql, $args);
  }
  drupal_set_message(t('The queue has been updated'));
}

/**
 * Confirm form to clear a queue.
 */
function nodequeue_clear_confirm($queue, $subqueue) {
  $form['sqid'] = array('#type' => 'value', '#value' => $subqueue->sqid);
  $form['qid'] = array('#type' => 'value', '#value' => $queue->qid);
  return confirm_form($form,
    t('Clearing queue "%s" is irreversible. You sure?', array('%s' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))),
    $_GET['destination'] ? $_GET['destination'] : "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid",
    t('This action cannot be undone.'),
    t('Clear Queue'), t('Cancel')
  );
}

/**
 * Submit function for nodequeue clear confirm
 */
function nodequeue_clear_confirm_submit($formid, $form) {
  if ($form['confirm']) {
    nodequeue_queue_clear($form['sqid']);
    return "admin/content/nodequeue/$form[qid]/view/$form[sqid]";
  }
}

// --------------------------------------------------------------------------
// Nodequeue manipulation API.

/**
 * @defgroup nodequeue_api
 * @{
 * Access to the internals of nodequeues are handled primarily through these
 * API functions. They allow easy loading of queues for manipulation.
 */

/**
 * The nodequeue queue class; the constructor makes it so we don't have to
 * always check to see if our variables are empty or not.
 */
class nodequeue_queue {
  var $title = '';
  var $size = 0;
  var $link = '';
  var $remove_link = '';
  var $roles = array();
  var $types = array();
  var $show_in_links = TRUE;
  var $show_in_tab = TRUE;
  var $show_in_ui = TRUE;
  var $reference = 0;

  var $subqueue = array();
  function nodequeue_queue($type) {
    $this->owner = $type;
  }
}

/**
 * Return TRUE If the specified account has access to manipulate this queue.
 */
function nodequeue_queue_access($queue, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  // Automatically true if all queues.
  if (user_access('manipulate all queues')) {
    return TRUE;
  }

  // Automatically false if they can't manipulate queues at all.
  if (!user_access('manipulate queues')) {
    return FALSE;
  }

  $roles = array_keys((array) $account->roles) + array(DRUPAL_AUTHENTICATED_RID);
  return (bool) array_interect($roles, $queue->roles);
}

/**
 * Fetch a list of available queues for a given location. These queues
 * will be fully loaded and ready to go.
 */
function nodequeue_load_queues_by_type($type, $location = NULL) {
  $qids = nodequeue_get_qids($type, $account);
  if ($location) {
    nodequeue_filter_qids($qids, $location);
  }
  return nodequeue_load_queues(array_keys($qids));
}

/**
 * Return TRUE if $user can queue(s) for this node.
 *
 * @param $type
 *   The node type.
 * @param $location
 *   Optional argument. May be one of:
 *   - 'links': Only check for queues that have node links.
 *   - 'tab': Only check for queues that appear on the node tab.
 *   - 'ui': Only check for queues that appear in the UI.
 */
function nodequeue_node_access($type, $location = NULL, $account = NULL) {
  $qids = nodequeue_get_qids($type, $account);
  if ($location) {
    nodequeue_filter_qids($qids, $location);
  }

  return !empty($qids);
}

/**
 * Filter a list of qids returned by nodequeue_get_qids to a location.
 *
 * @param $qids
 *   An array of $qids from @see nodequeue_get_qids()
 * @param $location
 *   One of:
 *   - 'links': Only check for queues that have node links.
 *   - 'tab': Only check for queues that appear on the node tab.
 *   - 'ui': Only check for queues that appear in the UI.
 */
function nodequeue_filter_qids(&$qids, $location) {
  $var = "show_in_$location";
  foreach ($qids as $qid => $info) {
    if (empty($info->$var)) {
      unset($qids[$qid]);
    }
  }
}

/**
 * Get an array of qids applicable to this node type.
 *
 * @param $type
 *   The node type.
 * @param $account
 *   The account to test against. Defaults to the currently logged in user.
 *
 * @return $qids
 *   An array in the format: @code { array($qid => array('qid' => $qid, 'show_in_tab' '
 *   => true/false, 'show_in_links' => true/false }
 */
function nodequeue_get_qids($type, $account = NULL) {
  if (!isset($account)) {
    global $user;
    $account = $user;
  }

  static $cache = array();
  if (!isset($cache[$type])) {
    $roles_join = $roles_where = '';
    $roles = array();

    // superuser always has access.
    if (!user_access('manipulate all queues')) {
      $roles_join = "INNER JOIN {nodequeue_roles} nr ON nr.qid = nq.qid ";
      $roles = array_keys((array) $account->roles) + array(DRUPAL_AUTHENTICATED_RID);
      $role_args = array_fill(0, count($roles), '%d');

      $roles_where .= "AND nr.rid IN (". implode(',', $role_args) .")";
    }

    $sql = 'SELECT nq.qid, nq.show_in_tab, nq.show_in_links, show_in_ui ' .
      'FROM {nodequeue_queue} nq ' .
      'INNER JOIN {nodequeue_types} nt ON nt.qid = nq.qid ' . $roles_join .
      "WHERE nt.type = '%s' " . $roles_where;
    $result = db_query($sql, array_merge(array($type), $roles));

    $qids = array();
    while ($qid = db_fetch_object($result)) {
      $qids[$qid->qid] = $qid;
    }
    $cache[$type] = $qids;
  }
  return $cache[$type];
}

/**
 * Get an array all qids using the pager query. This administrative list
 * does no permission checking, so should only be available to users who
 * have passed the 'administer queues' check.
 *
 * @param $page_size
 *   The page size to use. If 0 will be all queues.
 * @param $pager_element
 *   In the rare event this should use another pager element, set this..
 *
 * @return $qids
 *   An array in the format: @code { array($qid => array('qid' => $qid, 'show_in_tab' '
 *   => true/false, 'show_in_links' => true/false }
 */
function nodequeue_get_all_qids($page_size = 25, $pager_element = 0) {
  static $cache = NULL;
  if (!isset($cache)) { 
    $sql = 'SELECT nq.qid ' .
           'FROM {nodequeue_queue} nq ' .
           'WHERE nq.show_in_ui = 1 ';
    $count_sql = 'SELECT COUNT(q.qid) FROM {nodequeue_queue} q WHERE q.show_in_ui = 1 ';
    if ($page_size) {
      $result = pager_query($sql, $page_size, $pager_element, $count_sql);
    }
    else {
      $result = db_query($sql, $count_sql);
    }

    $qids = array();
    while ($qid = db_fetch_object($result)) {
      $qids[$qid->qid] = $qid->qid;
    }
    $cache = $qids;
  }
  return $cache;
}

/**
 * Load an array of $qids.
 *
 * This exists to provide a way of loading a bunch of queues with
 * the fewest queries. Loading 5 queues results in only 4 queries,
 * not 20. This also caches queues so that they don't get loaded
 * repeatedly.
 *
 * @param $qids
 *   An array of queue IDs to load.
 */
function nodequeue_load_queues($qids) {
  static $cache = array();
  $to_load = array();

  foreach ($qids as $qid) {
    if (!isset($cache[$qid])) {
      $to_load[] = $qid;
    }
  }

  if (!empty($to_load)) {
    $load_text = implode(', ', $to_load);
    $result = db_query("SELECT q.*, COUNT(s.sqid) AS subqueues FROM {nodequeue_queue} q LEFT JOIN {nodequeue_subqueue} s ON q.qid = s.qid WHERE q.qid IN (%s) GROUP BY q.qid", $load_text);
    while ($queue = db_fetch_object($result)) {
      $cache[$queue->qid] = $queue;
    }

    $result = db_query("SELECT * FROM {nodequeue_roles} WHERE qid IN (%s)", $load_text);
    while ($obj = db_fetch_object($result)) {
      $cache[$obj->qid]->roles[] = $obj->rid;
    }

    $result = db_query("SELECT * FROM {nodequeue_types} WHERE qid IN (%s)", $load_text);
    while ($obj = db_fetch_object($result)) {
      $cache[$obj->qid]->types[] = $obj->type;
    }
  }

  foreach ($qids as $qid) {
    if (isset($cache[$qid])) {
      $queues[$qid] = $cache[$qid];
    }
  }
  return $queues;
}

/**
 * Load a nodequeue.
 *
 * @param $qid
 *   The qid of the queue to load.
 */
function nodequeue_load($qid) {
  $queues = nodequeue_load_queues(array($qid));
  return array_shift($queues);
}

/**
 * Load a list of subqueues
 *
 * This exists to provide a way of loading a bunch of queues with
 * the fewest queries. Loading 5 queues results in only 4 queries,
 * not 20. This also caches queues so that they don't get loaded
 * repeatedly.
 *
 * @param $sqids
 *   An array of subqueue IDs to load.
 */
function nodequeue_load_subqueues($sqids) {
  static $cache = array();
  $to_load = array();

  foreach ($sqids as $sqid) {
    if (!isset($cache[$sqid])) {
      $to_load[] = $sqid;
    }
  }

  if (!empty($to_load)) {
    $load_text = implode(', ', $to_load);

    $result = db_query("SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE s.sqid IN (%s) GROUP BY s.sqid", $load_text);
    while ($obj = db_fetch_object($result)) {
      // Sometimes we want to get to subqueues by reference, sometimes by sqid.
      // sqid is always unique, but reference is sometimes more readily available.
      $cache[$obj->sqid] = $obj;
    }
  }

  foreach ($sqids as $sqid) {
    if (isset($cache[$sqid])) {
      $subqueues[$sqid] = $cache[$sqid];
    }
  }
  return $subqueues;
}

/**
 * Load a single subqueue.
 *
 * @param $sqid
 *   The subqueue ID to load.
 */
function nodequeue_load_subqueue($sqid) {
  $subqueues = nodequeue_load_subqueues(array($sqid));
  if ($subqueues) {
    return array_shift($subqueues);
  }

}

/**
 * Load the entire set of subqueues for a queue.
 *
 * This will load the entire set of subqueues for a given queue (and can
 * respect the pager, if desired). It does NOT cache the subqueues like
 * nodequeue_load_subqueues does, so beware of this mixed caching.
 *
 * @param $qids
 *   A $qid or array of $qids
 * @param $page_size
 *   If non-zero, use the pager_query and limit the page-size to the parameter.
 */
function nodequeue_load_subqueues_by_queue($qids, $page_size = 0) {
  if (is_numeric($qids)) {
    $qids = array($qids);
  }

  $query = "SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE s.qid IN (" . implode(', ', array_fill(0, count($qids), '%d')). ") GROUP BY s.sqid";
  if ($page_size) {
    $result = pager_query($query, $page_size, 0, $qids);
  }
  else {
    $result = db_query($query, $qids);
  }

  $subqueues = array();

  while ($subqueue = db_fetch_object($result)) {
    $subqueues[$subqueue->sqid] = $subqueue;
  }

  return $subqueues;
}

/**
 * Load a set of subqueues by reference.
 *
 * This can be used to load a set of subqueues by reference; it will primarily
 * be used by plugins that are managing subqueues.
 *
 * @param $references
 *   A keyed array of references to load. The key is the $qid and each value
 *   is another array of references.
 */
function nodequeue_load_subqueues_by_reference($references) {
  static $cache = array();
  $subqueues = array();

  // build strings for the query based upon the qids and references.
  $keys = $values = array();
  foreach ($references as $qid => $qid_references) {
    $keys[$qid] = array();
    $qid_values = array();
    foreach ($qid_references as $reference) {
      // If we already have this qid/reference combo cached, don't add it to
      // our little list.
      if (isset($cache[$qid][$reference])) {
        $subqueues[$cache[$qid][$reference]->sqid] = $cache[$qid][$reference];
      }
      else {
        $keys[$qid][] = "'%s'";
        $qid_values[] = $reference;
      }
    }
    if (!empty($keys[$qid])) {
      $values = array_merge($values, array($qid), $qid_values);
    }
    else {
      unset($keys[$qid]);
    }
  }

  if (!empty($keys)) {
    $where = '';
    foreach ($keys as $key_list) {
      if ($where) {
        $where .= ' OR ';
      }
      $where .= 's.qid = %d AND s.reference IN (' . implode(', ', $key_list) . ')';
    }

    $result = db_query("SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE $where GROUP BY s.sqid", $values);

    while ($subqueue = db_fetch_object($result)) {
      $cache[$subqueue->qid][$subqueue->reference] = $subqueues[$subqueue->sqid] = $subqueue;
    }
  }

  return $subqueues;  
}

/**
 * Save a nodequeue. This does not save subqueues; those must be added separately.
 */
function nodequeue_save(&$queue) {
  if (!isset($queue->qid)) {
    $queue->qid = db_next_id("{nodequeue_queue}_qid");
    db_query("INSERT INTO {nodequeue_queue} (qid, title, subuqueue_title, size, link, link_remove, owner, show_in_links, show_in_tab, show_in_ui, reference) VALUES (%d, '%s', '%s', %d, '%s', '%s', '%s', %d, %d, %d, '%s')", $queue->qid, $queue->title, $queue->subqueue_title, $queue->size, $queue->link, $queue->link_remove, $queue->owner, $queue->show_in_links, $queue->show_in_tab, $queue->show_in_ui, $queue->reference);
    if (function_exists('views_invalidate_cache')) {
      views_invalidate_cache();
    }
  }
  else {
    db_query("UPDATE {nodequeue_queue} set size = %d, title = '%s', subqueue_title = '%s', link = '%s', link_remove = '%s', owner = '%s', show_in_links = %d, show_in_tab = %d, show_in_ui = %d, reference = '%s' WHERE qid = %d", $queue->size, $queue->title, $queue->subqueue_title, $queue->link, $queue->link_remove, $queue->owner, $queue->show_in_links, $queue->show_in_tab, $queue->show_in_ui, $queue->reference, $queue->qid);
    db_query("DELETE FROM {nodequeue_roles} WHERE qid = %d", $queue->qid);
    db_query("DELETE FROM {nodequeue_types} WHERE qid = %d", $queue->qid);
    if ($nodes) {
      db_query("DELETE FROM {nodequeue_nodes} WHERE qid = %d", $queue->qid);
    }
  }

  if (is_array($queue->roles)) {
    foreach($queue->roles as $rid)
      db_query("INSERT INTO {nodequeue_roles} (qid, rid) VALUES (%d, %d)", $queue->qid, $rid);
  }

  if (is_array($queue->types)) {
    foreach($queue->types as $type)
    db_query("INSERT INTO {nodequeue_types} (qid, type) VALUES (%d, '%s')", $queue->qid, $type);
  }

  // set our global that tells us whether or not we need to activate hook_link
  if (db_result(db_query("SELECT COUNT(*) FROM {nodequeue_queue} WHERE link != ''"))) {
    variable_set('nodequeue_links', TRUE);
  }
  else {
    variable_set('nodequeue_links', FALSE);
  }

  if (isset($queue->add_subqueue) && is_array($queue->add_subqueue)) {
    foreach ($queue->add_subqueue as $reference => $title) {
      // If reference is unset it should be set to the qid; this is generally
      // used for a single subqueue; setting the reference to the qid makes
      // it easy to find that one subqueue.
      if ($reference == 0) {
        $reference = $queue->qid;
      }
      nodequeue_add_subqueue($queue, $title, $reference);
    }
  }
  return $queue->qid;
}

/**
 * Delete a nodequeue.
 */
function nodequeue_delete($qid) {
  db_query("DELETE FROM {nodequeue_queue} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_roles} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_types} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_nodes} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_subqueue} WHERE qid = %d", $qid);
}

/**
 * Add a new subqueue to a queue.
 *
 * @param $qid
 *   The queue id. This should not be the full queue object.
 * @param $reference
 *   A reference that uniquely identifies this subqueue. If NULL it will
 *   be assigned to the sqid.
 */
function nodequeue_add_subqueue(&$queue, $title, $reference = NULL) {
  $sqid = db_next_id('{nodequeue_subqueue}_sqid');
  if (empty($reference)) {
    $reference = $sqid;
  }

  $subqueue = new stdClass();
  $subqueue->sqid = $sqid;
  $subqueue->reference = $reference;
  $subqueue->qid = $queue->qid;
  $subqueue->title = $title;

  db_query("INSERT INTO {nodequeue_subqueue} (qid, sqid, reference, title) VALUES (%d, %d, '%s', '%s')", $queue->qid, $sqid, $reference, $title);

  return $subqueue;
}

/**
 * Change the title of a subqueue.
 *
 * Note that only the title of a subqueue is changeable; it can change to
 * reflect updates in taxonomy term names, for example.
 */
function nodequeue_subqueue_update_title($sqid, $title) {
  db_query("UPDATE {nodequeue_subqueue} SET title = '%s' WHERE $sqid = %d", $title, $sqid);
}

/**
 * Remove an a subqueue.
 */
function nodequeue_remove_subqueue($sqid) {
  db_query("DELETE FROM {nodequeue_subqueue} WHERE sqid = %d", $sqid);
}

// --------------------------------------------------------------------------
// Queue position control

/**
 * Add a node to a queue.
 *
 * @param $queue
 *   The parent queue of the subqueue. This is required so that we can
 *   pop nodes out if the queue breaks size limits.
 * @param $sqid
 *   The subqueue ID to add the node to.
 * @param $nid
 *   The node ID
 */
function nodequeue_subqueue_add($queue, $subqueue, $nid) {
  // If adding this would make the queue too big, pop the front node
  // (or nodes) out.

  if ($queue->size) {
    // 0 means infinity so never do this if false
    nodequeue_check_subqueue_size($queue, $subqueue, $queue->size - 1);
  }

  db_query("INSERT INTO {nodequeue_nodes} (sqid, qid, nid, position, timestamp) VALUES (%d, %d, %d, %d, %d)", $subqueue->sqid, $queue->qid, $nid, $subqueue->count + 1, time());
}

/**
 * Remove a node from the queue. If a node is in the queue more than once,
 * only the first (closest to 0 position, or the front of the queue) will
 * be removed.
 *
 * @param $qid
 *   Either the QID of a queue, or an already loaded queue object.
 * @param $nid
 *   The node to remove.
 * @param $sqid
 *   The subqueue to remove nodes from.
 */
function nodequeue_subqueue_remove_node($sqid, $nid) {
  if ($pos = nodequeue_get_subqueue_position($sqid, $nid)) {
    nodequeue_subqueue_remove($sqid, $pos);
  }
}

/**
 * Remove a node or node(s) from a nodequeue by position.
 */
function nodequeue_subqueue_remove($sqid, $start, $end = NULL) {
  if (!isset($end)) {
    $end = $start;
  }

  $diff = $end - $start + 1;
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position >= %d AND position <= %d", $sqid, $start, $end);
  db_query("UPDATE {nodequeue_nodes} SET position = position - %d WHERE sqid = %d AND position > %d",  $diff, $sqid, $end);
}

/**
 * Empty a subqueue.
 *
 * @param $sqid
 *   The sqid to empty.
 */
function nodequeue_queue_clear($sqid) {
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d", $sqid);
}

/**
 * Guarantee that a subqueue has not gotten too big. It's important to call
 * this after an operation that might have reduced a queue's maximum size.
 * It stores the count to save a query if this is to be followed by an add
 * operation.
 *
 * @param $queue
 *   The queue object.
 * @param $reference
 *   The subqueue to check.
 *
 */
function nodequeue_check_subqueue_size($queue, &$subqueue, $size = NULL) {
  if (!isset($size)) {
    $size = $queue->size;
  }

  if ($subqueue->count > $size) {
    nodequeue_subqueue_remove($subqueue->sqid, 1, $subqueue->count - $size);
    $subqueue->count = $size;
  }
}

/**
 * Guarantee that all subqueues are within the size constraints set
 * by $queue->size.
 */
function nodequeue_check_subqueue_sizes($queue) {
  // Don't check if size is 0, as that means infinite size.
  if (!$queue->size) {
    return;
  }

  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
  foreach ($subqueues as $subqueue) {
    nodequeue_check_subqueue_size($queue, $subqueue);
  }
}

/**
 * Swap two positions within a subqueue.
 */
function nodequeue_queue_swap($subqueue, $pos1, $pos2) {
  // Grab the nid off one of the positions so we can more easily swap.
  $nid = db_result(db_query("SELECT nid FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $pos1));
  if (!$nid) {
    return;
  }

  db_query("UPDATE {nodequeue_nodes} SET position = %d WHERE position = %d AND sqid = %d", $pos1, $pos2,  $subqueue->sqid);
  db_query("UPDATE {nodequeue_nodes} SET position = %d WHERE nid = %d AND sqid = %d", $pos2, $nid, $subqueue->sqid);
}

/**
 * Move a position within a subqueue up by one.
 */
function nodequeue_queue_up($subqueue, $position) {
  if ($position < 2 || $position > $subqueue->count)
    return;
  nodequeue_queue_swap($subqueue, $position - 1, $position);
}

/**
 * Move a position within a subqueue down by one.
 */
function nodequeue_queue_down($subqueue, $position) {
  if ($position < 1 || $position >= $subqueue->count)
    return;
  nodequeue_queue_swap($subqueue, $position + 1, $position);
}

/**
 * Move an item to the front of the queue.
 */
function nodequeue_queue_front($subqueue, $position) {
  if ($position < 2 || $position > $subqueue->count)
    return;
  $entry = db_fetch_object(db_query("SELECT * FROM {nodequeue_nodes} WHERE sqid= %d AND position = %d", $subqueue->sqid, $position));
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position);
  db_query("UPDATE {nodequeue_nodes} SET position = position + 1 WHERE sqid= %d AND position < %d", $subqueue->sqid, $position);
  db_query("INSERT INTO {nodequeue_nodes} (sqid, nid, position, timestamp) VALUES (%d, %d, 1, %d)", $subqueue->sqid, $entry->nid, $entry->timestamp);
}

/**
 * Move an item to the back of the queue.
 */
function nodequeue_queue_back($subqueue, $position) {
  if ($position < 1 || $position >= $subqueue->count)
    return;
  $entry = db_fetch_object(db_query("SELECT * FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position));
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position);
  db_query("UPDATE {nodequeue_nodes} SET position = position - 1 WHERE sqid = %d AND position > %d", $subqueue->sqid, $position);
  db_query("INSERT INTO {nodequeue_nodes} (sqid, nid, position, timestamp) VALUES (%d, %d, %d, %d)", $subqueue->sqid, $entry->nid, $subqueue->count, $entry->timestamp);
}

/**
 * Get the position of a node in a subqueue, or 0 if not found.
 */
function nodequeue_get_subqueue_position($sqid, $nid) {
  // We use MIN to make sure we always get the closes to the front of the
  // queue in case the queue has nodes in it multiple times.
  $pos = db_result(db_query("SELECT MIN(position) FROM {nodequeue_nodes} WHERE sqid = %d AND nid = %d", $sqid, $nid));
  return $pos;
}

/**
 * Get the position of a node in several subqueues.
 */
function nodequeue_set_subqueue_positions(&$subqueues, $nid) {
  $result = db_query("SELECT sqid, MIN(position) AS position FROM {nodequeue_nodes} WHERE sqid IN (%s) AND nid = %d GROUP BY sqid", implode(', ', array_keys($subqueues)), $nid);
  while ($obj = db_fetch_object($result)) {
    $subqueues[$obj->sqid]->position = $obj->position;
  }
}

/**
 * Get a list of valid subqueues for a node, along with the position of the node.
 *
 * @param $queues
 *   An array of fully loaded queue objects.
 * @param $node
 *   A fully loaded node object.
 *
 */
function nodequeue_get_subqueues_by_node($queues, $node) {
  // Determine which subqueues are valid for each queue.
  $references= array();
  foreach ($queues as $queue) {
    if ($result = nodequeue_api_subqueues($queue, $node)) {
      $references[$queue->qid] = is_array($result) ? $result : array($result);
    }
  }

  if (empty($references)) {
    return;
  }

  return nodequeue_load_subqueues_by_reference($references);
}

/**
 * Get a textual representation of a nodequeue's queue size.
 */
function nodequeue_subqueue_size_text($max, $count, $long = TRUE) {
  if (empty($count)) {
    $message = t('Queue empty');
  }
  else if ($count == $max) {
    $message = t('Queue full');
  }
  else {
    if ($long) {
      $message = t('@count in queue', array('@count' => $count));
    }
    else {
      $message = $count;
    }
  }
  return $message;
}

/**
 * Substitute the subqueue title into some others tring.
 *
 * This function does NOT check_plain the title! The output MUST be checked
 * after this is complete.
 */
function nodequeue_title_substitute($text, $queue, $subqueue) {
  if (empty($text)) {
    return $subqueue->title;
  }
  $text = str_replace('%subqueue', $subqueue->title, $text);
  return $text;
}

/**
 * @} End of defgroup "nodequeue_api"
 */

// --------------------------------------------------------------------------
// Hooks to implement the default nodequeue type.

/**
 * Implementation of hook_nodequeue_info()
 */
function nodequeue_nodequeue_info() {
  return array('nodequeue' => array(
    'title' => t('Node queue'),
    'description' => t('Standard node queues have just one subqueue. Nodes put into a queue are added to the back of the queue; when a node is added to a full queue, the node in the front of the queue will be popped out to make room.'),
    ));
}

/**
 * Implementation of hook_nodequeue_form_submit()
 */
function nodequeue_nodequeue_form_submit(&$queue, $form) {
  // This will add a single subqueue to our new queue.
  if (!isset($queue->qid) && !isset($queue->add_subqueue)) {
    // A 0 will set the reference to the sqid of the queue.
    $queue->add_subqueue = array(0 => $queue->title);
  }
}

// --------------------------------------------------------------------------
// External queue fetching

/**
 * in general it's preferable to use Views for this functionality.
 */
function nodequeue_node_titles($sqid, $title = '', $backward = true, $from = 0, $count = 0) {
  $orderby = ($backward ? "DESC" : "ASC");
  $sql = db_rewrite_sql("SELECT n.nid, n.title FROM {node} n LEFT JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1 ORDER BY nn.position $orderby");
  if ($count) {
    $result = db_query_range($sql, $sqid, $from, $count);
  }
  else {
    $result = db_query($sql, $sqid);
  }
  return node_title_list($result, $title);
}

function nodequeue_nodes($sqid, $backward = true, $teaser = true, $links = true, $from = 0, $count = 0) {
  $orderby = ($backward ? "DESC" : "ASC");
  $sql = db_rewrite_sql("SELECT n.nid FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1 ORDER BY nn.position $orderby");
  if ($count) {
    $result = db_query_range($sql, $sqid, $from, $count);
  }
  else {
    $result = db_query($sql, $sqid);
  }

  while ($nid = db_fetch_object($result)) {
    $node = node_load($nid->nid);
    $output .= node_view($node, $teaser, false, $links);
  }
  return $output;
}

function nodequeue_fetch_front($sqid, $teaser = true, $links = true) {
  return nodequeue_nodes($sqid, false, $teaser, $links, 0, 1);
}

function nodequeue_fetch_back($sqid, $teaser = true, $links = true) {
  return nodequeue_nodes($sqid, true, $teaser, $links, 0, 1);
}

function nodequeue_fetch_random($sqid, $teaser = true, $links = true) {
  $count = db_result(db_query("SELECT count(*) FROM {nodequeue_nodes} WHERE sqid = %d", $sqid));
  return nodequeue_nodes($sqid, false, $teaser, $links, rand(0, $count - 1), 1);
}

// --------------------------------------------------------------------------
// API for modules implementing subqueues.

/**
 * Send the nodequeue edit form to the owning module for modification.
 *
 * @param $queue
 *   The queue being edited.
 * @param &$form
 *   The form. This may be modified.
 */
function nodequeue_api_queue_form($queue, &$form) {
  $function = $queue->owner . "_nodequeue_form";
  if (function_exists($function)) {
    $function($queue, $form);
  }
}

/**
 * Validate the nodequeue edit form.
 *
 * @param $queue
 *   The queue being edited.
 * @param $form_values
 *   The form values that were submitted.
 * @param &$form
 *   The actual form object. This may be modified.
 */
function nodequeue_api_queue_form_validate($queue, $form_values, &$form) {
  $function = $queue->owner . "_nodequeue_form_validate";
  if (function_exists($function)) {
    $function($queue, $form_values, $form);
  }
}

/**
 * Send the nodequeue edit form to the owning module upon submit.
 *
 * @param &$queue
 *   The queue being edited. This may be modified prior to being
 *   saved.
 * @param $form_values
 *   The form values that were submitted.
 */
function nodequeue_api_queue_form_submit(&$queue, $form_values) {
  $function = $queue->owner . "_nodequeue_form_submit";
  if (function_exists($function)) {
    $function($queue, $form_values);
  }
}

/**
 * Send the nodequeue edit form to the owning module after the queue
 * has been saved.
 *
 * @param &$queue
 *   The queue being edited. This may be modified prior to being
 *   saved.
 * @param $form_values
 *   The form values that were submitted.
 */
function nodequeue_api_queue_form_submit_finish($queue, $form_values) {
  $function = $queue->owner . "_nodequeue_form_submit_finish";
  if (function_exists($function)) {
    $function($queue, $form_values);
  }
}

/**
 * Fetch a list of subqueues that are valid for this node from
 * the owning module.
 *
 * @param $queue
 *   The queue being edited.
 * @param $node
 *   The loaded node object being checked.
 *
 * @return
 *   An array of subqueues. This will be keyed by $sqid.
 */
function nodequeue_api_subqueues(&$queue, $node) {
  $function = $queue->owner . "_nodequeue_subqueues";
  // This will return an array of references.
  if (function_exists($function)) {
    return $function($queue, $node);
  }
  else {
    return $queue->qid;
  }
}

/**
 * Collect info about all of the possible nodequeue tyeps from owning
 * modules.
 */
function nodequeue_api_info() {
  return module_invoke_all('nodequeue_info');
}
